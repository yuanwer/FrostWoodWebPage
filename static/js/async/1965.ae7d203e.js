"use strict";(self.webpackChunkFrostWood=self.webpackChunkFrostWood||[]).push([["1965"],{8738:function(n,e,t){t.r(e),t.d(e,{default:function(){return s}});var i=t(5893),r=t(65);function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code"},(0,r.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"节流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#节流",children:"#"}),"节流"]}),"\n",(0,i.jsx)(e.p,{children:"概念：节流函数的作用是限制函数的执行频率，在一定时间内只能执行一次。"}),"\n",(0,i.jsx)(e.p,{children:"使用场景："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"窗口滚动事件"}),"\n",(0,i.jsx)(e.li,{children:"鼠标移动事件"}),"\n",(0,i.jsx)(e.li,{children:"窗口大小调整事件"}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"时间戳节流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#时间戳节流",children:"#"}),"时间戳节流"]}),"\n",(0,i.jsx)(e.p,{children:"计算当前时间与上次执行时间的差值，如果差值大于时间限制，则执行函数。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",meta:"",children:" /** \n* @desc 函数节流\n* @param func 回调函数 \n* @param limit 时间限制\n* @param immediate 是否立即执行，默认为true\n*/ \nfunction throttle(func, limit, immediate = true) { \n    //上次执行时间 \n    let previous = 0; \n    return function() { \n        //当前时间 \n        let now = Date.now(); \n\n        let context = this; \n        let args = arguments; \n        \n        // 首次执行时\n        if (previous === 0 && !immediate) {\n            previous = now;\n            return;\n        }\n        \n        // 若当前时间-上次执行时间大于时间限制\n        if (now - previous > limit) { \n            func.apply(context, args); \n            previous = now; \n        } \n    } \n} \n\n\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"定时器节流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#定时器节流",children:"#"}),"定时器节流"]}),"\n",(0,i.jsx)(e.p,{children:"使用定时器，在规定时间内，如果再次执行函数，则清除定时器，重新计时。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",meta:"",children:" /** \n* @desc 函数节流\n* @param func 回调函数 \n* @param limit 时间限制\n* @param immediate 是否立即执行\n*/ \nconst throttle = (func, limit, immediate = true) => {\n    let inThrottle;  // 是否处于节流限制时间内\n    let timer;\n\n    return function() {\n        const context = this;\n        const args = arguments;\n\n        if (immediate) {\n            // 立即执行模式\n            if (!inThrottle) {\n                func.apply(context, args);  // 立即执行回调\n                inThrottle = true;\n                // 开启定时器计时\n                setTimeout(() => inThrottle = false, limit);\n            }\n        } else {\n            // 非立即执行模式\n            if (!inThrottle) {\n                inThrottle = true;\n                timer = setTimeout(() => {\n                    func.apply(context, args);\n                    inThrottle = false;\n                }, limit);\n            }\n        }\n    }\n}\n\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"uview-ui-节流",children:[(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#uview-ui-节流",children:"#"}),"uview-ui 节流"]}),"\n",(0,i.jsxs)(e.p,{children:["以下代码来自 uview-ui 2.0 组件库源码，",(0,i.jsx)(e.a,{href:"https://github.com/umicro/uView2.0/blob/master/uni_modules/uview-ui/libs/function/throttle.js",rel:"noopener noreferrer",target:"_blank",children:"原始代码"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"特点是，如果一个页面引入了此函数，并且A、B两个函数都使用了此节流函数，那么A、B函数都会使用同一个timer。这意味着，如果A先执行，B后执行，并且间隔时间小于wait，那么B函数不会执行。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",meta:"",children:"let timer = null;\nlet flag = false;\n/**\n * 节流原理：在一定时间内，只能触发一次\n *\n * @param {Function} func 要执行的回调函数\n * @param {Number} wait 延时的时间\n * @param {Boolean} immediate 是否立即执行\n * @return null\n */\nfunction throttle(func, wait = 500, immediate = true) {\n    if (immediate) {\n        if (!flag) {\n            flag = true\n            // 如果是立即执行，则在wait毫秒内开始时执行\n            typeof func === 'function' && func()\n            timer = setTimeout(() => {\n                flag = false\n            }, wait)\n        }\n    } else if (!flag) {\n        flag = true\n        // 如果是非立即执行，则在wait毫秒内的结束处执行\n        timer = setTimeout(() => {\n            flag = false\n            typeof func === 'function' && func()\n        }, wait)\n    }\n}\nexport default throttle\n"})})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(a,n)})):a(n)}let s=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["front-end%2Fcode-snippet%2F%E8%8A%82%E6%B5%81.mdx"]={toc:[{id:"时间戳节流",text:"时间戳节流",depth:2},{id:"定时器节流",text:"定时器节流",depth:2},{id:"uview-ui-节流",text:"uview-ui 节流",depth:2}],title:"节流",frontmatter:{}}}}]);