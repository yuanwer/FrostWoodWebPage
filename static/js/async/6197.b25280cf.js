"use strict";(self.webpackChunkFrostWood=self.webpackChunkFrostWood||[]).push([["6197"],{9756:function(e,n,s){s.r(n),s.d(n,{default:function(){return a}});var r=s(5893),t=s(65);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",div:"div",ol:"ol",li:"li"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"js-中的计时是否精确",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#js-中的计时是否精确",children:"#"}),"JS 中的计时是否精确"]}),"\n",(0,r.jsx)(n.p,{children:"首先回答：JS 中的计时是不精确的。"}),"\n",(0,r.jsx)(n.p,{children:"下面是测试代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",meta:"",children:"const iterations = 10;\nconst delay = 1000; // 1秒\nconst results = [];\n\nfunction measureTimeout() {\n  const start = performance.now();\n  \n  setTimeout(() => {\n    const end = performance.now();\n    const diff = end - start - delay;\n    results.push(diff);\n    \n    if (results.length < iterations) {\n      measureTimeout();\n    } else {\n      // 计算平均误差\n      const avgDiff = results.reduce((a, b) => a + b, 0) / results.length;\n      console.log(`平均误差: ${avgDiff.toFixed(2)}ms`);\n      console.log('所有误差:', results.map(d => d.toFixed(2)));\n    }\n  }, delay);\n}\n\nmeasureTimeout();\n"})}),"\n",(0,r.jsx)(n.p,{children:"打印结果："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{meta:"",children:"平均误差: 7.02ms\n所有误差: (10)\xa0['15.60', '7.00', '1.90', '3.10', '5.30', '3.00', '7.40', '8.90', '14.60', '3.40']\n"})}),"\n",(0,r.jsx)(n.p,{children:"JS 中的计时不精确的原因，可以从以下 5 个方面来分析。"}),"\n",(0,r.jsxs)(n.h2,{id:"硬件限制",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#硬件限制",children:"#"}),"硬件限制"]}),"\n",(0,r.jsx)(n.p,{children:"JS 所有的计时器最终都要在硬件层面执行。普通计算设备（如电脑和手机）的计时系统存在固有误差。目前只有原子钟能实现高精度计时，它利用原子的振动频率来计时。由于消费级电子设备不包含原子钟，从硬件层面来说，JS 计时就无法做到绝对精确。"}),"\n",(0,r.jsxs)(n.h2,{id:"浏览器与操作系统的通信",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器与操作系统的通信",children:"#"}),"浏览器与操作系统的通信"]}),"\n",(0,r.jsx)(n.p,{children:"JS 的 setTimeout、setInterval 这类计时器 API 是由浏览器实现的。浏览器需要调用操作系统提供的计时相关 API，而不同操作系统（Windows、MacOS、Linux 等）的计时 API 实现各不相同，这导致了跨平台计时存在误差。另外，浏览器调用系统 API 的过程本身也会产生延迟。"}),"\n",(0,r.jsxs)(n.h2,{id:"html-规范的限制",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#html-规范的限制",children:"#"}),"HTML 规范的限制"]}),"\n",(0,r.jsxs)(n.p,{children:["根据 HTML Living Standard 规范（参考",(0,r.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers",rel:"noopener noreferrer",target:"_blank",children:"HTML Living Standard 对 JS 定时器的规范"}),"），当 setTimeout 或 setInterval 发生嵌套，且嵌套层级达到或超过 5 层时，时间间隔会被强制设置为至少 4 毫秒。这是一个明确的规范限制。"]}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive note",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"规范原文及翻译"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.（计时器可以嵌套；但是，在五个嵌套的计时器之后，时间间隔会被强制设置为至少四毫秒。）"}),"\n",(0,r.jsx)(n.li,{children:"This API does not guarantee that timers will run exactly on schedule. Delays due to CPU load, other tasks, etc, are to be expected.（这个 API 不能保证计时器会按计划运行。由于 CPU 负载、其他任务等原因，延迟是不可避免的。）"}),"\n"]})})]}),"\n",(0,r.jsx)(n.p,{children:"关于第一个规定，下面的代码可以验证："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",meta:"",children:"let count = 0;\nfunction nestedTimeout() {\n  count++;\n  console.log(`第 ${count} 层嵌套，当前时间：${performance.now()}`);\n  \n  if (count < 7) {\n    setTimeout(nestedTimeout, 0);\n  }\n}\n\nnestedTimeout();\n"})}),"\n",(0,r.jsx)(n.p,{children:"打印结果："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{meta:"",children:"第 1 层嵌套，当前时间：1628424\n第 2 层嵌套，当前时间：1628424.1999999993\n第 3 层嵌套，当前时间：1628424.5\n第 4 层嵌套，当前时间：1628424.5\n第 5 层嵌套，当前时间：1628424.5\n第 6 层嵌套，当前时间：1628429.1999999993\n第 7 层嵌套，当前时间：1628433.8000000007\n"})}),"\n",(0,r.jsx)(n.p,{children:"通过观察可以发现，当嵌套层级超过 5 层后，从第 6 层开始，每次计时的时间间隔都被强制设置为至少 4 毫秒。"}),"\n",(0,r.jsxs)(n.h2,{id:"事件循环机制",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件循环机制",children:"#"}),"事件循环机制"]}),"\n",(0,r.jsx)(n.p,{children:"计时器触发后，相关的回调函数会被放入任务队列。根据 ECMAScript 规范中的事件循环模型，只有当当前执行栈清空后，才会处理任务队列中的任务。示例代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",meta:"",children:'// 设置一个定时器，1秒后执行\nsetTimeout(() => {\n  console.log("定时器执行了", Date.now() - start);\n}, 1000);\n\nconst start = Date.now();\n\n// 执行耗时操作\nfor (let i = 0; i < 5000000000; i++) {\n  // 空循环\n}\n\nconsole.log("循环结束了", Date.now() - start);\n'})}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive note",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"NOTE"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsx)(n.p,{children:"根据 WHATWG 规范，现代浏览器中的任务队列系统实际上包含多个专门的队列，它们具有不同的优先级，而不是传统意义上的宏任务和微任务的简单区分。"})})]}),"\n",(0,r.jsxs)(n.h2,{id:"运行环境的影响",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#运行环境的影响",children:"#"}),"运行环境的影响"]}),"\n",(0,r.jsxs)(n.p,{children:["浏览器针对性能和电源管理做了诸多优化。参考",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#%E5%BB%B6%E6%97%B6%E6%AF%94%E6%8C%87%E5%AE%9A%E5%80%BC%E6%9B%B4%E9%95%BF%E7%9A%84%E5%8E%9F%E5%9B%A0",rel:"noopener noreferrer",target:"_blank",children:"MDN 文档"}),"，当标签页处于非活动状态时，计时器会被强制添加一个延迟时间。此外，设备性能不足、系统负载过高等因素都会影响计时器的精确性。"]}),"\n",(0,r.jsx)(n.p,{children:"总结来说，由于硬件限制、系统实现差异、Web 标准规范限制以及运行环境的多重因素影响，JS 中实现完全精确的计时是不可能的。"}),"\n",(0,r.jsxs)(n.h2,{id:"安全限制",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#安全限制",children:"#"}),"安全限制"]}),"\n",(0,r.jsxs)(n.p,{children:["你可能了解过 ",(0,r.jsx)(n.code,{children:"performance.now()"})," 这个 API，它被设计用来提供高精度的时间戳（微秒级，比 ",(0,r.jsx)(n.code,{children:"Date.now()"})," 更精确）。"]}),"\n",(0,r.jsxs)(n.p,{children:["但为了防止时间攻击和指纹识别，浏览器厂商对其精度进行了限制。可以参考 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now",rel:"noopener noreferrer",target:"_blank",children:"Performance.now()"}),"："]}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive note",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"原文"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsx)(n.p,{children:"这个时间戳实际上并不是高精度的。为了降低像Spectre这样的安全威胁，各类浏览器对该类型的值做了不同程度上的四舍五入处理。（Firefox 从 Firefox 59 开始四舍五入到 2 毫秒精度）一些浏览器还可能对这个值作稍微的随机化处理。这个值的精度在未来的版本中可能会再次改善；浏览器开发者还在调查这些时间测定攻击和如何更好的缓解这些攻击。"})})]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,r.jsx)(n.p,{children:"JS 中的计时不精确，主要受硬件限制、浏览器与操作系统的通信、HTML 规范的限制、事件循环机制、运行环境的影响以及安全限制等因素影响。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(i,e)})):i(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["front-end%2Fjavascript%2FJS%E4%B8%AD%E7%9A%84%E8%AE%A1%E6%97%B6%E6%98%AF%E5%90%A6%E7%B2%BE%E7%A1%AE.mdx"]={toc:[{id:"硬件限制",text:"硬件限制",depth:2},{id:"浏览器与操作系统的通信",text:"浏览器与操作系统的通信",depth:2},{id:"html-规范的限制",text:"HTML 规范的限制",depth:2},{id:"事件循环机制",text:"事件循环机制",depth:2},{id:"运行环境的影响",text:"运行环境的影响",depth:2},{id:"安全限制",text:"安全限制",depth:2},{id:"总结",text:"总结",depth:2}],title:"JS 中的计时是否精确",frontmatter:{}}}}]);