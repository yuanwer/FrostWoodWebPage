"use strict";(self.webpackChunkFrostWood=self.webpackChunkFrostWood||[]).push([["6162"],{8834:function(e,n,r){r.r(n),r.d(n,{default:function(){return i}});var c=r(5893),s=r(65),o=r(9641);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",strong:"strong",div:"div",img:"img"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"js-原型链",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#js-原型链",children:"#"}),"JS 原型链"]}),"\n",(0,c.jsx)(n.p,{children:"JavaScript 的原型链是其最具特色的机制之一,是实现对象继承的基础,也是理解 JavaScript 面向对象编程的关键概念。"}),"\n",(0,c.jsxs)(n.h2,{id:"对象的创建",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象的创建",children:"#"}),"对象的创建"]}),"\n",(0,c.jsx)(n.p,{children:'要理解原型链的全貌，我们需要从一个最基本的问题开始思考："对象是从哪里来的？"'}),"\n",(0,c.jsxs)(n.p,{children:["在 JavaScript 中，对象都是通过 ",(0,c.jsx)(n.code,{children:"new"})," 操作符和构造函数创建出来的。即使是最简单的对象字面量，本质上也是通过构造函数创建的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",meta:"",children:"// 使用字面量方式创建对象\nconst obj = {};\n\n// 上面的写法实际上是下面这种方式的语法糖\nconst obj = new Object();\n"})}),"\n",(0,c.jsx)(n.p,{children:"明白了对象的创建方式，我们来深入理解原型链的概念。"}),"\n",(0,c.jsxs)(n.h2,{id:"函数与原型对象",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数与原型对象",children:"#"}),"函数与原型对象"]}),"\n",(0,c.jsxs)(n.p,{children:['在 JavaScript 中，每个函数都有一个特殊的"孪生兄弟" —— 原型对象（prototype）。当我们通过 ',(0,c.jsx)(n.code,{children:"new"})," 操作符使用函数创建实例时，这个实例会自动获得一个特殊的属性 ",(0,c.jsx)(n.code,{children:"__proto__"}),"（隐式原型），它指向创建该实例的函数的原型对象。"]}),"\n",(0,c.jsx)(n.p,{children:"让我们通过一个例子来说明："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",meta:"",children:"function Person() {}\nconst person = new Person();\n\nconsole.log(person.__proto__ === Person.prototype); // true\n"})}),"\n",(0,c.jsx)(n.p,{children:"这三者之间的关系可以用下面的图来表示："}),"\n",(0,c.jsx)(o.Z,Object.assign({code:"graph TD\n    A[Person 函数] --\x3e |prototype| B[Person.prototype]\n    C[person 实例] --\x3e |__proto__| B\n    A --\x3e |new| C"},{config:{}})),"\n",(0,c.jsxs)(n.p,{children:["这个图展示了函数、原型对象和实例之间的基本关系：函数通过 prototype 属性连接到原型对象，实例通过 ",(0,c.jsx)(n.strong,{children:"proto"})," 属性连接到原型对象。"]}),"\n",(0,c.jsxs)(n.h2,{id:"原型链的形成",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链的形成",children:"#"}),"原型链的形成"]}),"\n",(0,c.jsxs)(n.p,{children:["那么，",(0,c.jsx)(n.code,{children:"Person.prototype"})," 本身又是什么呢？它其实也是一个对象，是通过 ",(0,c.jsx)(n.code,{children:"new Object()"})," 创建的。因此，它也有自己的 ",(0,c.jsx)(n.code,{children:"__proto__"}),"，指向 ",(0,c.jsx)(n.code,{children:"Object.prototype"}),"："]}),"\n",(0,c.jsx)(o.Z,Object.assign({code:"graph TD\n    A[Object 函数] --\x3e |prototype| B[Object.prototype]\n    C[Person.prototype] --\x3e |__proto__| B\n    A --\x3e |new| C"},{config:{}})),"\n",(0,c.jsxs)(n.p,{children:["特别需要注意的是，",(0,c.jsx)(n.code,{children:"Object.prototype"})," 原型对象，它的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 被 js 引擎默认设置为 ",(0,c.jsx)(n.code,{children:"null"}),"。这样做是为了避免无限循环的原型链。"]}),"\n",(0,c.jsxs)(n.p,{children:["这个 ",(0,c.jsx)(n.code,{children:"null"})," 就是原型链的顶端。"]}),"\n",(0,c.jsxs)(n.div,{className:"rspress-directive info",children:[(0,c.jsx)(n.div,{className:"rspress-directive-title",children:"为什么会导致无限循环"}),(0,c.jsxs)(n.div,{className:"rspress-directive-content",children:[(0,c.jsxs)(n.p,{children:["如果 js 引擎没有设置 ",(0,c.jsx)(n.code,{children:"Object.prototype"})," 的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 为 ",(0,c.jsx)(n.code,{children:"null"}),"，那么 ",(0,c.jsx)(n.code,{children:"Object.prototype"})," 是一个普通对象，也是由 ",(0,c.jsx)(n.code,{children:"new Object"})," 得来的，那么 ",(0,c.jsx)(n.code,{children:"Object.prototype"})," 对象的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 属性又会指向 ",(0,c.jsx)(n.code,{children:"Object.prototype"})," 对象自身。"]}),(0,c.jsx)(n.p,{children:"这样就会形成一个无限的循环链，js 引擎在原型链上查找属性时，就会陷入死循环。"})]})]}),"\n",(0,c.jsxs)(n.h2,{id:"函数的本质",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数的本质",children:"#"}),"函数的本质"]}),"\n",(0,c.jsxs)(n.p,{children:["在 JavaScript 中，函数本质上也是对象，是一种可调用的特殊对象。所有的函数，包括我们常用的 ",(0,c.jsx)(n.code,{children:"Object"}),"、",(0,c.jsx)(n.code,{children:"Array"})," 等内置函数，都是通过 ",(0,c.jsx)(n.code,{children:"new Function()"})," 创建的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",meta:"",children:'function sum(a, b) {\n  return a + b;\n}\n\n// 等价于\nconst sum = new Function("a", "b", "return a + b");\n'})}),"\n",(0,c.jsxs)(n.p,{children:["这就解释了为什么函数对象（比如 ",(0,c.jsx)(n.code,{children:"Object"})," 函数）的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 会指向 ",(0,c.jsx)(n.code,{children:"Function.prototype"}),"："]}),"\n",(0,c.jsx)(o.Z,Object.assign({code:"graph TD\n    A[Function 函数] --\x3e |prototype| B[Function.prototype]\n    C[Object 函数] --\x3e |__proto__| B\n    A --\x3e |new| C"},{config:{}})),"\n",(0,c.jsxs)(n.h2,{id:"function-函数的特殊性",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#function-函数的特殊性",children:"#"}),"Function 函数的特殊性"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Function"})," 函数是 JavaScript 引擎启动时就创建的特殊对象，它是所有函数的根源。作为一个特例，它的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 指向自己的原型对象 ",(0,c.jsx)(n.code,{children:"Function.prototype"}),"："]}),"\n",(0,c.jsx)(o.Z,Object.assign({code:"graph TD\n    A[Function 函数] --\x3e |prototype| B[Function.prototype]\n    A --\x3e |__proto__| B"},{config:{}})),"\n",(0,c.jsxs)(n.p,{children:["而 ",(0,c.jsx)(n.code,{children:"Function.prototype"})," 作为一个普通对象，是由 ",(0,c.jsx)(n.code,{children:"new Object()"})," 创建的，所以它的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 指向 ",(0,c.jsx)(n.code,{children:"Object.prototype"}),"，形成了完整的原型链闭环。"]}),"\n",(0,c.jsxs)(n.h2,{id:"原型链的实际应用",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链的实际应用",children:"#"}),"原型链的实际应用"]}),"\n",(0,c.jsx)(n.p,{children:"让我们看一个实际的例子，展示原型链在开发中的应用："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",meta:"",children:"// 创建一个自定义数组方法\nArray.prototype.sum = function() {\n  return this.reduce((acc, curr) => acc + curr, 0);\n};\n\nconst numbers = [1, 2, 3, 4];\nconsole.log(numbers.sum()); // 输出：10\n\n// 这个例子展示了如何通过原型链扩展内置对象的功能\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"完整的原型链图谱",children:[(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#完整的原型链图谱",children:"#"}),"完整的原型链图谱"]}),"\n",(0,c.jsx)(n.p,{children:"下图展示了 JavaScript 中完整的原型链关系："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"/docs-images/js%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg",alt:"原型链关系图"})}),"\n",(0,c.jsx)(n.p,{children:"通过这个关系图，我们可以清晰地看到所有对象、函数以及它们的原型之间的联系，这就是 JavaScript 原型链的全貌。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,Object.assign({},e,{children:(0,c.jsx)(t,e)})):t(e)}let i=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["front-end%2Fjavascript%2Fjs%E5%8E%9F%E5%9E%8B%E9%93%BE.mdx"]={toc:[{id:"对象的创建",text:"对象的创建",depth:2},{id:"函数与原型对象",text:"函数与原型对象",depth:2},{id:"原型链的形成",text:"原型链的形成",depth:2},{id:"函数的本质",text:"函数的本质",depth:2},{id:"function-函数的特殊性",text:"Function 函数的特殊性",depth:2},{id:"原型链的实际应用",text:"原型链的实际应用",depth:2},{id:"完整的原型链图谱",text:"完整的原型链图谱",depth:2}],title:"JS 原型链",frontmatter:{}}}}]);